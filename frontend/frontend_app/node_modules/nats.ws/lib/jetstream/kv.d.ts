import { MsgHdrs, Payload, QueuedIterator } from "../nats-base-client/core";
import { JetStreamClient, JetStreamManager, KV, KvCodec, KvCodecs, KvDeleteOptions, KvEntry, KvOptions, KvPutOptions, KvRemove, KvStatus, KvWatchInclude, KvWatchOptions, StoredMsg } from "./types";
import { ConsumerConfig, Placement, PurgeOpts, PurgeResponse, Republish, StorageType, StreamInfo } from "./jsapi_types";
import { JsMsg } from "./jsmsg";
export declare function Base64KeyCodec(): KvCodec<string>;
export declare function NoopKvCodecs(): KvCodecs;
export declare function defaultBucketOpts(): Partial<KvOptions>;
export declare const kvOperationHdr = "KV-Operation";
export declare function validateKey(k: string): void;
export declare function validateSearchKey(k: string): void;
export declare function hasWildcards(k: string): boolean;
export declare function validateBucket(name: string): void;
export declare class Bucket implements KV, KvRemove {
    js: JetStreamClient;
    jsm: JetStreamManager;
    stream: string;
    bucket: string;
    direct: boolean;
    codec: KvCodecs;
    prefix: string;
    editPrefix: string;
    useJsPrefix: boolean;
    _prefixLen: number;
    constructor(bucket: string, js: JetStreamClient, jsm: JetStreamManager);
    static create(js: JetStreamClient, name: string, opts?: Partial<KvOptions>): Promise<KV>;
    static bind(js: JetStreamClient, name: string, opts?: Partial<KvOptions>): Promise<KV>;
    init(opts?: Partial<KvOptions>): Promise<void>;
    initializePrefixes(info: StreamInfo): void;
    bucketName(): string;
    subjectForBucket(): string;
    subjectForKey(k: string, edit?: boolean): string;
    fullKeyName(k: string): string;
    get prefixLen(): number;
    encodeKey(key: string): string;
    decodeKey(ekey: string): string;
    validateKey: typeof validateKey;
    validateSearchKey: typeof validateSearchKey;
    hasWildcards: typeof hasWildcards;
    close(): Promise<void>;
    dataLen(data: Uint8Array, h?: MsgHdrs): number;
    smToEntry(sm: StoredMsg): KvEntry;
    jmToEntry(jm: JsMsg): KvEntry;
    create(k: string, data: Payload): Promise<number>;
    update(k: string, data: Payload, version: number): Promise<number>;
    put(k: string, data: Payload, opts?: Partial<KvPutOptions>): Promise<number>;
    get(k: string, opts?: {
        revision: number;
    }): Promise<KvEntry | null>;
    purge(k: string, opts?: Partial<KvDeleteOptions>): Promise<void>;
    delete(k: string, opts?: Partial<KvDeleteOptions>): Promise<void>;
    purgeDeletes(olderMillis?: number): Promise<PurgeResponse>;
    _deleteOrPurge(k: string, op: "DEL" | "PURGE", opts?: Partial<KvDeleteOptions>): Promise<void>;
    _doDeleteOrPurge(k: string, op: "DEL" | "PURGE", opts?: Partial<KvDeleteOptions>): Promise<void>;
    _buildCC(k: string | string[], content: KvWatchInclude, opts?: Partial<ConsumerConfig>): Partial<ConsumerConfig>;
    remove(k: string): Promise<void>;
    history(opts?: {
        key?: string | string[];
        headers_only?: boolean;
    }): Promise<QueuedIterator<KvEntry>>;
    canSetWatcherName(): boolean;
    watch(opts?: KvWatchOptions): Promise<QueuedIterator<KvEntry>>;
    keys(k?: string): Promise<QueuedIterator<string>>;
    purgeBucket(opts?: PurgeOpts): Promise<PurgeResponse>;
    destroy(): Promise<boolean>;
    status(): Promise<KvStatus>;
}
export declare class KvStatusImpl implements KvStatus {
    si: StreamInfo;
    cluster: string;
    constructor(si: StreamInfo, cluster?: string);
    get bucket(): string;
    get values(): number;
    get history(): number;
    get ttl(): number;
    get bucket_location(): string;
    get backingStore(): StorageType;
    get storage(): StorageType;
    get replicas(): number;
    get description(): string;
    get maxBucketSize(): number;
    get maxValueSize(): number;
    get max_bytes(): number;
    get placement(): Placement;
    get placementCluster(): string;
    get republish(): Republish;
    get streamInfo(): StreamInfo;
    get size(): number;
    get metadata(): Record<string, string>;
    get compression(): boolean;
}
