"use strict";
/*
 * Copyright 2020-2024 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsTransport = void 0;
const internal_mod_1 = require("../nats-base-client/internal_mod");
const VERSION = "1.27.0";
const LANG = "nats.ws";
class WsTransport {
    constructor() {
        this.version = VERSION;
        this.lang = LANG;
        this.connected = false;
        this.done = false;
        this.socketClosed = false;
        this.encrypted = false;
        this.peeked = false;
        this.yields = [];
        this.signal = (0, internal_mod_1.deferred)();
        this.closedNotification = (0, internal_mod_1.deferred)();
    }
    connect(server, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const connected = false;
            const connLock = (0, internal_mod_1.deferred)();
            // ws client doesn't support TLS setting
            if (options.tls) {
                connLock.reject(new internal_mod_1.NatsError("tls", internal_mod_1.ErrorCode.InvalidOption));
                return connLock;
            }
            this.options = options;
            const u = server.src;
            if (options.wsFactory) {
                const { socket, encrypted } = yield options.wsFactory(server.src, options);
                this.socket = socket;
                this.encrypted = encrypted;
            }
            else {
                this.encrypted = u.indexOf("wss://") === 0;
                this.socket = new WebSocket(u);
            }
            this.socket.binaryType = "arraybuffer";
            this.socket.onopen = () => {
                if (this.isDiscarded()) {
                    return;
                }
                // we don't do anything here...
            };
            this.socket.onmessage = (me) => {
                if (this.isDiscarded()) {
                    return;
                }
                this.yields.push(new Uint8Array(me.data));
                if (this.peeked) {
                    this.signal.resolve();
                    return;
                }
                const t = internal_mod_1.DataBuffer.concat(...this.yields);
                const pm = (0, internal_mod_1.extractProtocolMessage)(t);
                if (pm !== "") {
                    const m = internal_mod_1.INFO.exec(pm);
                    if (!m) {
                        if (options.debug) {
                            console.error("!!!", (0, internal_mod_1.render)(t));
                        }
                        connLock.reject(new Error("unexpected response from server"));
                        return;
                    }
                    try {
                        const info = JSON.parse(m[1]);
                        (0, internal_mod_1.checkOptions)(info, this.options);
                        this.peeked = true;
                        this.connected = true;
                        this.signal.resolve();
                        connLock.resolve();
                    }
                    catch (err) {
                        connLock.reject(err);
                        return;
                    }
                }
            };
            // @ts-ignore: CloseEvent is provided in browsers
            this.socket.onclose = (evt) => {
                if (this.isDiscarded()) {
                    return;
                }
                this.socketClosed = true;
                let reason;
                if (this.done)
                    return;
                if (!evt.wasClean) {
                    reason = new Error(evt.reason);
                }
                this._closed(reason);
            };
            // @ts-ignore: signature can be any
            this.socket.onerror = (e) => {
                if (this.isDiscarded()) {
                    return;
                }
                const evt = e;
                const err = new internal_mod_1.NatsError(evt.message, internal_mod_1.ErrorCode.Unknown, new Error(evt.error));
                if (!connected) {
                    connLock.reject(err);
                }
                else {
                    this._closed(err);
                }
            };
            return connLock;
        });
    }
    disconnect() {
        this._closed(undefined, true);
    }
    _closed(err_1) {
        return __awaiter(this, arguments, void 0, function* (err, internal = true) {
            if (this.isDiscarded()) {
                return;
            }
            if (!this.connected)
                return;
            if (this.done)
                return;
            this.closeError = err;
            if (!err) {
                while (!this.socketClosed && this.socket.bufferedAmount > 0) {
                    yield (0, internal_mod_1.delay)(100);
                }
            }
            this.done = true;
            try {
                // 1002 endpoint error, 1000 is clean
                this.socket.close(err ? 1002 : 1000, err ? err.message : undefined);
            }
            catch (err) {
                // ignore this
            }
            if (internal) {
                this.closedNotification.resolve(err);
            }
        });
    }
    get isClosed() {
        return this.done;
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate() {
        return __asyncGenerator(this, arguments, function* iterate_1() {
            while (true) {
                if (this.isDiscarded()) {
                    return yield __await(void 0);
                }
                if (this.yields.length === 0) {
                    yield __await(this.signal);
                }
                const yields = this.yields;
                this.yields = [];
                for (let i = 0; i < yields.length; i++) {
                    if (this.options.debug) {
                        console.info(`> ${(0, internal_mod_1.render)(yields[i])}`);
                    }
                    yield yield __await(yields[i]);
                }
                // yielding could have paused and microtask
                // could have added messages. Prevent allocations
                // if possible
                if (this.done) {
                    break;
                }
                else if (this.yields.length === 0) {
                    yields.length = 0;
                    this.yields = yields;
                    this.signal = (0, internal_mod_1.deferred)();
                }
            }
        });
    }
    isEncrypted() {
        return this.connected && this.encrypted;
    }
    send(frame) {
        if (this.isDiscarded()) {
            return;
        }
        try {
            this.socket.send(frame.buffer);
            if (this.options.debug) {
                console.info(`< ${(0, internal_mod_1.render)(frame)}`);
            }
            return;
        }
        catch (err) {
            // we ignore write errors because client will
            // fail on a read or when the heartbeat timer
            // detects a stale connection
            if (this.options.debug) {
                console.error(`!!! ${(0, internal_mod_1.render)(frame)}: ${err}`);
            }
        }
    }
    close(err) {
        return this._closed(err, false);
    }
    closed() {
        return this.closedNotification;
    }
    // check to see if we are discarded, as the connection
    // may not have been closed, we attempt it here as well.
    isDiscarded() {
        if (this.done) {
            this.discard();
            return true;
        }
        return false;
    }
    // this is to allow a force discard on a connection
    // if the connection fails during the handshake protocol.
    // Firefox for example, will keep connections going,
    // so eventually if it succeeds, the client will have
    // an additional transport running. With this
    discard() {
        var _a;
        this.done = true;
        try {
            (_a = this.socket) === null || _a === void 0 ? void 0 : _a.close();
        }
        catch (_err) {
            // ignored
        }
    }
}
exports.WsTransport = WsTransport;
//# sourceMappingURL=ws_transport.js.map