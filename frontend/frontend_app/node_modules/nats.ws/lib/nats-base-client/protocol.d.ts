import { Transport } from "./transport";
import { Deferred, Timeout } from "./util";
import { DataBuffer } from "./databuffer";
import { ServerImpl, Servers } from "./servers";
import { DispatchedFn, IngestionFilterFn, ProtocolFilterFn, QueuedIteratorImpl } from "./queued_iterator";
import { MuxSubscription } from "./muxsubscription";
import { Heartbeat } from "./heartbeats";
import { MsgArg, Parser, ParserEvent } from "./parser";
import { Features } from "./semver";
import { Base, ConnectionOptions, Dispatcher, Msg, NatsError, Payload, Publisher, PublishOptions, QueuedIterator, Request, Server, ServerInfo, Status, Subscription, SubscriptionOptions } from "./core";
export declare const INFO: RegExp;
export declare class Connect {
    echo?: boolean;
    no_responders?: boolean;
    protocol: number;
    verbose?: boolean;
    pedantic?: boolean;
    jwt?: string;
    nkey?: string;
    sig?: string;
    user?: string;
    pass?: string;
    auth_token?: string;
    tls_required?: boolean;
    name?: string;
    lang: string;
    version: string;
    headers?: boolean;
    constructor(transport: {
        version: string;
        lang: string;
    }, opts: ConnectionOptions, nonce?: string);
}
export declare class SubscriptionImpl extends QueuedIteratorImpl<Msg> implements Base, Subscription {
    sid: number;
    queue?: string;
    draining: boolean;
    max?: number;
    subject: string;
    drained?: Promise<void>;
    protocol: ProtocolHandler;
    timer?: Timeout<void>;
    info?: unknown;
    cleanupFn?: (sub: Subscription, info?: unknown) => void;
    closed: Deferred<void>;
    requestSubject?: string;
    constructor(protocol: ProtocolHandler, subject: string, opts?: SubscriptionOptions);
    setPrePostHandlers(opts: {
        ingestionFilterFn?: IngestionFilterFn<Msg>;
        protocolFilterFn?: ProtocolFilterFn<Msg>;
        dispatchedFn?: DispatchedFn<Msg>;
    }): void;
    callback(err: NatsError | null, msg: Msg): void;
    close(): void;
    unsubscribe(max?: number): void;
    cancelTimeout(): void;
    drain(): Promise<void>;
    isDraining(): boolean;
    isClosed(): boolean;
    getSubject(): string;
    getMax(): number | undefined;
    getID(): number;
}
export declare class Subscriptions {
    mux: SubscriptionImpl | null;
    subs: Map<number, SubscriptionImpl>;
    sidCounter: number;
    constructor();
    size(): number;
    add(s: SubscriptionImpl): SubscriptionImpl;
    setMux(s: SubscriptionImpl | null): SubscriptionImpl | null;
    getMux(): SubscriptionImpl | null;
    get(sid: number): SubscriptionImpl | undefined;
    resub(s: SubscriptionImpl): SubscriptionImpl;
    all(): (SubscriptionImpl)[];
    cancel(s: SubscriptionImpl): void;
    handleError(err?: NatsError): boolean;
    close(): void;
}
export declare class ProtocolHandler implements Dispatcher<ParserEvent> {
    connected: boolean;
    connectedOnce: boolean;
    infoReceived: boolean;
    info?: ServerInfo;
    muxSubscriptions: MuxSubscription;
    options: ConnectionOptions;
    outbound: DataBuffer;
    pongs: Array<Deferred<void>>;
    subscriptions: Subscriptions;
    transport: Transport;
    noMorePublishing: boolean;
    connectError?: (err?: Error) => void;
    publisher: Publisher;
    _closed: boolean;
    closed: Deferred<Error | void>;
    listeners: QueuedIterator<Status>[];
    heartbeats: Heartbeat;
    parser: Parser;
    outMsgs: number;
    inMsgs: number;
    outBytes: number;
    inBytes: number;
    pendingLimit: number;
    lastError?: NatsError;
    abortReconnect: boolean;
    whyClosed: string;
    servers: Servers;
    server: ServerImpl;
    features: Features;
    connectPromise: Promise<void> | null;
    constructor(options: ConnectionOptions, publisher: Publisher);
    resetOutbound(): void;
    dispatchStatus(status: Status): void;
    status(): AsyncIterable<Status>;
    private prepare;
    disconnect(): void;
    reconnect(): Promise<void>;
    disconnected(err?: Error): Promise<void>;
    dial(srv: Server): Promise<void>;
    _doDial(srv: Server): Promise<void>;
    dialLoop(): Promise<void>;
    dodialLoop(): Promise<void>;
    static connect(options: ConnectionOptions, publisher: Publisher): Promise<ProtocolHandler>;
    static toError(s: string): NatsError;
    processMsg(msg: MsgArg, data: Uint8Array): void;
    processError(m: Uint8Array): void;
    handleError(err: NatsError): void;
    handleAuthError(err: NatsError): void;
    processPing(): void;
    processPong(): void;
    processInfo(m: Uint8Array): void;
    push(e: ParserEvent): void;
    sendCommand(cmd: string | Uint8Array, ...payloads: Uint8Array[]): void;
    publish(subject: string, payload?: Payload, options?: PublishOptions): void;
    request(r: Request): Request;
    subscribe(s: SubscriptionImpl): Subscription;
    _sub(s: SubscriptionImpl): void;
    _subunsub(s: SubscriptionImpl): SubscriptionImpl;
    unsubscribe(s: SubscriptionImpl, max?: number): void;
    unsub(s: SubscriptionImpl, max?: number): void;
    resub(s: SubscriptionImpl, subject: string): void;
    flush(p?: Deferred<void>): Promise<void>;
    sendSubscriptions(): void;
    private _close;
    close(): Promise<void>;
    isClosed(): boolean;
    drain(): Promise<void>;
    private flushPending;
    private initMux;
    private selectServer;
    getServer(): ServerImpl | undefined;
}
